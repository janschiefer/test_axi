pub proto package axi_prototype_unified {

    const INTERFACE_VERSION: string;

    type addr_t      ;
    type data_t      ;
    type strb_t      ;
    type num_bursts_t;
    type lock_t      ;
    type id_t        ;
    type awuser_t    ;
    type wuser_t     ;
    type buser_t     ;
    type aruser_t    ;
    type ruser_t     ;

}

pub package axi4_pkg::<ADDR_W: const, DATA_W_BYTES: const, ID_W: const, AWUSER_W: const, WUSER_W: const, BUSER_W: const, ARUSER_W: const, RUSER_W: const> for axi_prototype_unified {

    const INTERFACE_VERSION: string = "AXI4";

    type addr_t       = logic<ADDR_W>            ;
    type data_t       = logic<(DATA_W_BYTES * 8)>;
    type strb_t       = logic<DATA_W_BYTES>      ;
    type num_bursts_t = logic<8>                 ;
    type lock_t       = logic<1>                 ;
    type id_t         = logic<ID_W>              ;

    type awuser_t = logic<AWUSER_W>;
    type wuser_t  = logic<WUSER_W> ;
    type buser_t  = logic<BUSER_W> ;
    type aruser_t = logic<ARUSER_W>;
    type ruser_t  = logic<RUSER_W> ;
}

pub package axi3_pkg::<ADDR_W: const, DATA_W_BYTES: const, ID_W: const> for axi_prototype_unified {

    const INTERFACE_VERSION: string = "AXI3";

    type addr_t       = logic<ADDR_W>            ;
    type data_t       = logic<(DATA_W_BYTES * 8)>;
    type strb_t       = logic<DATA_W_BYTES>      ;
    type num_bursts_t = logic<4>                 ;
    type lock_t       = logic<2>                 ;
    type id_t         = logic<ID_W>              ;

    //Unused in AXI3
    type awuser_t = logic;
    type wuser_t  = logic;
    type buser_t  = logic;
    type aruser_t = logic;
    type ruser_t  = logic;
}

pub package axi4_lite_pkg::<ADDR_W: const, DATA_W_BYTES: const> for axi_prototype_unified {

    const INTERFACE_VERSION: string = "AXI4-Lite";

    type addr_t = logic<ADDR_W>            ;
    type data_t = logic<(DATA_W_BYTES * 8)>;
    type strb_t = logic<DATA_W_BYTES>      ;

    //Unused in AXI3
    type num_bursts_t = logic;
    type lock_t       = logic;
    type id_t         = logic;
    type awuser_t     = logic;
    type wuser_t      = logic;
    type buser_t      = logic;
    type aruser_t     = logic;
    type ruser_t      = logic;
}

pub interface axi_if_unified::<PKG: axi_prototype_unified> {

    import PKG::*;

    //Write address channel
    var awvalid : logic          ;
    var awready : logic          ;
    var awaddr  : addr_t         ;
    var awsize  : logic       <3>;
    var awburst : logic       <2>;
    var awcache : logic       <4>;
    var awprot  : logic       <3>;
    var awid    : id_t           ;
    var awlen   : num_bursts_t   ; //AXI3: 4 bits, AXI4: 8 bits
    var awlock  : lock_t         ; //AXI3: 2 bits, AXI4: 1 bit
    var awqos   : logic       <4>; //Only AXI4
    var awregion: logic       <4>; //Only AXI4
    var awuser  : awuser_t       ; //Only AXI4

    //Write data channel
    var wvalid: logic  ;
    var wready: logic  ;
    var wlast : logic  ;
    var wdata : data_t ;
    var wstrb : strb_t ;
    var wid   : id_t   ; //Only AXI3
    var wuser : wuser_t; //Only AXI4

    //Write response channel
    var bvalid: logic     ;
    var bready: logic     ;
    var bresp : logic  <2>;
    var bid   : id_t      ;
    var buser : buser_t   ; //Only AXI4

    //Read address channel
    var arvalid : logic          ;
    var arready : logic          ;
    var araddr  : addr_t         ;
    var arsize  : logic       <3>;
    var arburst : logic       <2>;
    var arcache : logic       <4>;
    var arprot  : logic       <3>;
    var arid    : id_t           ;
    var arlen   : num_bursts_t   ; //AXI3: 4 bits, AXI4: 8 bits
    var arlock  : lock_t         ; //AXI3: 2 bits, AXI4: 1 bit
    var arqos   : logic       <4>; //Only AXI4
    var arregion: logic       <4>; //Only AXI4
    var aruser  : aruser_t       ; //Only AXI4

    //Read data channel
    var rvalid: logic     ;
    var rready: logic     ;
    var rlast : logic     ;
    var rdata : data_t    ;
    var rresp : logic  <2>;
    var rid   : id_t      ;
    var ruser : ruser_t   ; //Only AXI4

    function awaddr_ack () -> logic {
        return awready && awvalid;
    }

    function wdata_ack () -> logic {
        return wready && wvalid;
    }

    function bresp_ack () -> logic {
        return bready && bvalid;
    }

    function araddr_ack () -> logic {
        return arready && arvalid;
    }

    function rdata_ack () -> logic {
        return rready && rvalid;
    }

    modport master {

        awvalid : output,
        awready : input ,
        awaddr  : output,
        awsize  : output,
        awburst : output,
        awcache : output,
        awprot  : output,
        awid    : output,
        awlen   : output,
        awlock  : output,
        awqos   : output,
        awregion: output,
        awuser  : output,

        wvalid: output,
        wready: input ,
        wlast : output,
        wdata : output,
        wstrb : output,
        wid   : output,
        wuser : output,

        bvalid: input ,
        bready: output,
        bresp : input ,
        bid   : input ,
        buser : input ,

        arvalid : output,
        arready : input ,
        araddr  : output,
        arsize  : output,
        arburst : output,
        arcache : output,
        arprot  : output,
        arid    : output,
        arlen   : output,
        arlock  : output,
        arqos   : output,
        arregion: output,
        aruser  : output,

        rvalid: input ,
        rready: output,
        rlast : input ,
        rdata : input ,
        rresp : input ,
        rid   : input ,
        ruser : input ,

        awaddr_ack: import,
        wdata_ack : import,
        bresp_ack : import,
        araddr_ack: import,
        rdata_ack : import,

    }

    modport slave {

        awaddr_ack: import,
        wdata_ack : import,
        bresp_ack : import,
        araddr_ack: import,
        rdata_ack : import,

        ..converse(master)
    }

    modport monitor {

        awaddr_ack: import,
        wdata_ack : import,
        bresp_ack : import,
        araddr_ack: import,
        rdata_ack : import,

        ..input
    }

    modport write_master {
        awvalid : output,
        awready : input ,
        awaddr  : output,
        awsize  : output,
        awburst : output,
        awcache : output,
        awprot  : output,
        awid    : output,
        awlen   : output,
        awlock  : output,
        awqos   : output,
        awregion: output,
        awuser  : output,

        wvalid: output,
        wready: input ,
        wlast : output,
        wdata : output,
        wstrb : output,
        wuser : output,

        bvalid: input ,
        bready: output,
        bresp : input ,
        bid   : input ,
        buser : input ,

        awaddr_ack: import,
        wdata_ack : import,
        bresp_ack : import,
    }

    modport read_master {

        arvalid : output,
        arready : input ,
        araddr  : output,
        arsize  : output,
        arburst : output,
        arcache : output,
        arprot  : output,
        arid    : output,
        arlen   : output,
        arlock  : output,
        arqos   : output,
        arregion: output,
        aruser  : output,

        rvalid: input ,
        rready: output,
        rlast : input ,
        rdata : input ,
        rresp : input ,
        rid   : input ,
        ruser : input ,

        araddr_ack: import,
        rdata_ack : import,

    }

    modport write_slave {

        awaddr_ack: import,
        wdata_ack : import,
        bresp_ack : import,

        ..converse(write_master)
    }

    modport read_slave {

        araddr_ack: import,
        rdata_ack : import,

        ..converse(read_master)
    }
}
